---
description: 规格编译器核心原则，定义不可违反的闸口规则和质量标准
---

# 核心原则（Core Principles）

本文档定义规格编译器的不可违反原则，所有阶段必须遵守。

## 一、闸口原则

### 1.1 闸口定义

每个 Stage 之间设置闸口，**人必须守，AI 必须等**。

| 闸口 | 位置 | 检查点 | 不通过则 |
|------|------|--------|----------|
| **PRD 闸** | Stage 1 → 2 | 需求清晰、边界明确、验收可测 | 不进入 DDD 设计 |
| **DDD 闸** | Stage 2 → 3 | 领域边界清晰、聚合合理、映射完整 | 不进入规格建模 |
| **建模闸** | Stage 3 → 4 | 状态完备、不变量完整、用例覆盖 | 不进入工件推导 |
| **工件闸** | Stage 4 → 编码 | 分层清晰、契约一致、位置明确 | 不允许生成代码 |
| **熵控闸** | 功能下线 | 删 case + 删代码 + 删配置 | 不允许遗留死代码 |

### 1.2 闸口执行规则

```
Stage N 完成
    ↓
输出产出物（完整文档）
    ↓
提醒用户 Review（列出检查要点）
    ↓
等待用户明确确认
    ↓
用户确认 → 进入 Stage N+1
用户修改 → 修改文档 → 再次提醒 Review
```

### 1.3 确认信号识别

**正面确认**（可进入下一阶段）：
- "继续"、"通过"、"没问题"、"可以了"、"OK"、"LGTM"

**需要修改**（停留当前阶段）：
- 提出具体修改意见
- 提问或质疑
- "等等"、"先不要"

**禁止行为**：
- 不能在用户未确认时自动进入下一 Stage
- 不能将沉默视为同意
- 不能假设用户已同意

## 二、建模原则

### 2.1 实体抽取原则（DDD）

实体必须满足三个条件：

1. **唯一标识** - 有全局唯一 ID
2. **生命周期** - 有创建、变更、终结
3. **状态转移** - 状态变化有明确规则

```
✅ 是实体：订单（有 ID、有生命周期、有状态流转）
✅ 是实体：会员订阅（有 ID、有生效/过期状态）
❌ 不是实体：金额（值对象，无 ID）
❌ 不是实体：配置项（无生命周期）
```

### 2.2 状态定义原则

状态必须满足：

1. **完备性** - 覆盖所有可能情况
2. **互斥性** - 任一时刻只能处于一个状态
3. **可观测性** - 状态可通过属性判断

```
✅ 好的状态定义：
enum OrderStatus {
    CREATED,      // 已创建
    PAID,         // 已支付
    SHIPPED,      // 已发货
    COMPLETED,    // 已完成
    CANCELLED     // 已取消
}

❌ 坏的状态定义：
- "处理中" （不明确）
- "异常" （太宽泛）
```

### 2.3 不变量原则

不变量是**永远为真**的业务规则：

1. **可验证** - 能写成断言
2. **无歧义** - 不依赖上下文理解
3. **可追溯** - 能关联到业务规则

```
✅ 好的不变量：
INV-1: 订单总金额 = Σ(商品单价 × 数量) - 优惠金额
INV-2: 已取消订单不能再次支付
INV-3: 库存数量 >= 0

❌ 坏的不变量：
- "订单金额要合理" （不可验证）
- "用户体验要好" （不是业务规则）
```

### 2.4 用例覆盖原则

用例必须包含：

1. **Happy Path** - 正常流程
2. **边界用例** - 边界值、空值、极值
3. **Bad Case** - 违反不变量的情况

```
用例覆盖矩阵：

| 用例 | 前置状态 | 操作 | 期望结果 | 覆盖不变量 |
|------|---------|------|---------|-----------|
| TC-1 | CREATED | 支付 | PAID | INV-1 |
| TC-2 | PAID | 支付 | 拒绝 | INV-2 |
| TC-3 | CANCELLED | 支付 | 拒绝 | INV-2 |
```

**Bad Case 必须存在**：没有 Bad Case 的用例集是不完整的。

## 三、工件推导原则

### 3.1 分层一致性

各端分层必须对应：

| 职责 | 后端 DDD | iOS MVVM | Vue 3 |
|------|---------|----------|-------|
| 展示 | Controller | View | View |
| 编排 | Application | ViewModel | Composable |
| 业务 | Domain | Service | Service |
| 数据 | Gateway/Infra | Gateway | API |
| 存储 | Mapper | Network | Request |

### 3.2 契约一致性

接口契约必须满足：

1. **入参一致** - 各端调用同一接口，入参结构相同
2. **返回一致** - 返回结构相同，错误码相同
3. **语义一致** - 同一字段在各端含义相同

### 3.3 位置明确性

每个逻辑必须有明确的实现位置：

```
❌ 模糊的描述：
"在合适的地方校验参数"

✅ 明确的描述：
"参数校验在 Controller 层执行，使用 @Valid 注解"
```

## 四、熵控原则

### 4.1 功能下线规则

功能下线必须执行：

1. **删除用例** - 从用例文档中移除
2. **删除代码** - 从各端代码中移除
3. **删除配置** - 从配置文件中移除
4. **删除文档** - 从 PRD/设计文档中标记废弃

### 4.2 禁止遗留

```
❌ 禁止：
- 注释掉的代码
- 标记 @Deprecated 但不删除
- "以后可能用到" 的保留代码
- 无引用的死代码

✅ 要求：
- 彻底删除
- 通过 Git 历史追溯
```

## 五、文档原则

### 5.1 单一事实源

每个信息只在一处定义：

- PRD 定义"做什么"
- DDD 设计定义"领域模型"
- 规格建模定义"状态和约束"
- 工件推导定义"如何实现"

### 5.2 可追溯性

每个决策必须可追溯：

```
代码实现 → 工件推导文档 → 规格建模文档 → DDD 设计 → PRD
```

### 5.3 版本一致性

文档变更必须同步：

- PRD 变更 → 检查 DDD 设计是否需要更新
- DDD 变更 → 检查规格建模是否需要更新
- 规格变更 → 检查工件推导是否需要更新
