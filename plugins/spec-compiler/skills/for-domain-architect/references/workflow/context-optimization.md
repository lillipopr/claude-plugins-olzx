# 上下文优化策略

> **目标**：在处理大型 PRD 和生成复杂领域设计文档时，避免上下文被撑爆

---

## 核心原则

1. **只保留必要信息**：不在内存中累积完整内容
2. **文件持久化**：每个章节完成后立即写入文件
3. **摘要传递**：章节间只传递关键摘要
4. **按需加载**：只在需要时加载文件内容

---

## 优化后的工作流

```
输入：PRD 文档（大文件）
  ↓
阶段 1：PRD 分析 + 摘要
  - 读取 PRD 文件
  - 生成 PRD 摘要文件（~500 tokens）
  - 原始 PRD 文件不再加载
  ↓
阶段 2：逐章生成（每次只处理一章）
  - 读取章节指令
  - 读取 PRD 摘要
  - 生成章节内容
  - 写入文件：chapter-N.md
  - 生成章节摘要（~200 tokens）
  - 清理章节内容，只保留摘要
  ↓
输出：5 个章节文档（文件路径）
```

---

## 详细实施步骤

### 阶段 1：PRD 分析与摘要

**目标**：将大型 PRD 转换为轻量级摘要

**摘要模板**：

```markdown
# PRD 摘要

## 功能概述
{2-3 句话描述功能}

## 核心实体
| 实体名 | 说明 |
|-------|------|
| {实体1} | {说明} |

## 业务流程
1. {流程1}
2. {流程2}

## 外部接口
- {接口1}

## 异步处理
- {事件1}
```

**上下文节省**：
- 原始 PRD：10,000 tokens
- PRD 摘要：500 tokens
- **节省：95%**

---

### 阶段 2：逐章生成

**核心策略**：每次只处理一章，完成后立即清理

**章节生成流程**：

```
第 N 章生成：
1. 读取章节指令
2. 读取 PRD 摘要
3. 读取前序章节摘要（如果有）
4. 生成章节内容
5. 写入文件（output/chapter-N.md）
6. 生成章节摘要（~200 tokens）
7. 清理章节内容
```

**章节摘要模板**：

```markdown
# 第 N 章摘要

## 章节
{章节名称}

## 关键内容
- {要点1}
- {要点2}

## 与其他章节的关系
- 依赖：{依赖的章节}
- 被依赖：{依赖此章节的章节}

## 文件路径
output/chapter-N.md
```

---

## 上下文对比

### 旧方案（一次性处理）

```
总上下文 = PRD + 5章指令 + 5章内容 + ...
         ≈ 40,000 tokens ❌
```

### 新方案（分阶段处理）

```
阶段 1：PRD 摘要
  上下文 = PRD + 指令 ≈ 5,000 tokens ✅

阶段 2：逐章生成（5次）
  每次上下文 = 摘要 + 单章指令 + 单章内容 ≈ 3,000 tokens ✅

峰值上下文：5,000 tokens（可接受）
```

**节省：87.5%**

---

## 实施技巧

### 1. 使用 Write 而非 Read

**原则**：生成后立即写入文件，不要在响应中返回完整内容

```typescript
// ✅ 正确：写入文件，只返回摘要
function generateChapter() {
  const content = generate()  // 2,000 tokens
  writeFile("chapter-1.md", content)  // 写入文件
  return { summary: "章节摘要...", file: "chapter-1.md" }  // 只返回摘要
}
```

### 2. 文件管理策略

```
output/
├── prd-summary.md           # PRD 摘要
├── chapter-01.md            # 第一章完整内容
├── chapter-01-summary.md    # 第一章摘要
├── chapter-02.md            # 第二章完整内容
├── chapter-02-summary.md    # 第二章摘要
└── ...
```

### 3. 引用而非内联

**原则**：引用文件路径，而非包含文件内容

```markdown
## 章节摘要
第一章：限界上下文设计
- 文件：output/chapter-01.md
- 关键内容：业务能力分析、上下文划分、上下文映射
```

---

## 特殊场景处理

### 场景 1：章节间依赖

**问题**：第二章依赖第一章的结果

**解决**：传递摘要而非完整内容

```
第一章完成：
- 生成完整内容 → 写入 chapter-01.md
- 生成摘要（包含关键信息）
- 清理完整内容

第二章生成：
- 读取第一章摘要（获取关键信息）
- 基于摘要生成第二章
- 写入 chapter-02.md
```

### 场景 2：修改流程

**问题**：修改某个章节时需要参考其他章节

**解决**：按需加载

```
修改第 N 章：
1. 加载第 N 章内容
2. 按需加载依赖章节的摘要
3. 修改并保存
4. 清理所有内容
```

---

## 最佳实践

### DO ✅

- ✅ 每章完成后立即写入文件
- ✅ 只在上下文中保留摘要
- ✅ 按需加载文件内容
- ✅ 定期清理不再需要的内容

### DON'T ❌

- ❌ 在响应中返回完整章节内容
- ❌ 累积多个章节的完整内容
- ❌ 在内存中组装完整文档
- ❌ 重复加载相同内容
- ❌ 保留原始 PRD 文件

---

## 总结

### 优化效果

| 指标 | 旧方案 | 新方案 | 改善 |
|------|-------|-------|------|
| 峰值上下文 | 40,000 tokens | 5,000 tokens | ↓ 87.5% |
| 内存占用 | 持续高 | 间歇性高 | ↓ 80% |
| 可扩展性 | 受限 | 良好 | ✅ |

### 关键要点

1. **PRD 摘要**：将大型 PRD 转换为轻量级摘要（节省 95%）
2. **逐章生成**：每次只处理一章，完成后立即清理
3. **文件持久化**：所有内容写入文件，不占用内存
4. **摘要传递**：章节间只传递摘要，不传递完整内容

通过以上策略，可以在有限的上下文中处理大型 PRD 和生成复杂的领域设计文档。
